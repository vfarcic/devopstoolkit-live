+++
archetype = "home"
title = ""
+++

# Latest Posts

<!-- <a href="/ai/better-code-reviews-with-ai-github-copilot-and-qodo-merge-tested"><img src="/ai/better-code-reviews-with-ai-github-copilot-and-qodo-merge-tested/thumbnail-01.png" style="width:50%; float:right; padding: 10px"></a>

## [Better Code Reviews with AI? GitHub Copilot and Qodo Merge Tested](/ai/better-code-reviews-with-ai-github-copilot-and-qodo-merge-tested)

Second opinions are important. We get them them from doctors, as well as from software engineers. We want "stuff" to be reviewed and we want feedback. Today, however, we will not talk about second opinions and suggestions from doctors and software engineers. We'll talk about **one AI reviewing work of another AI**, with us being managers of both.

Today we'll explore the possibilities of using a few AI agents to do code review. We'll see how they integrate into **pull requests in GitHub**, whether they can find issues in code written by a different AI in an IDE, and how we can incorporate those reviews into our development workflow.

**[Full article >>](/ai/better-code-reviews-with-ai-github-copilot-and-qodo-merge-tested)**

--- -->

<a href="/ai/my-workflow-with-ai-how-i-code-test-and-deploy-faster-than-ever"><img src="/ai/my-workflow-with-ai-how-i-code-test-and-deploy-faster-than-ever/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [My Workflow With AI: How I Code, Test, and Deploy Faster Than Ever](/ai/my-workflow-with-ai-how-i-code-test-and-deploy-faster-than-ever)

Today I want you share my **development workflow with AI**. I want to share how I start working on a new feature, how I manage product requirement documents, or PRDs, how I write code and test it, and how I move through the development lifecycle. The way I approach all that today is very different from the way I did all that in the past. There is a whole team working on each feature, with me being **the only human** involved.

**[Full article >>](/ai/my-workflow-with-ai-how-i-code-test-and-deploy-faster-than-ever)**

---

<a href="/ai/kubernetes-ai-the-good-the-bad-and-the-disappointing-kubectl-ai"><img src="/ai/kubernetes-ai-the-good-the-bad-and-the-disappointing-kubectl-ai/thumbnail.png" style="width:50%; float:right; padding: 10px"></a>

## [Kubernetes AI: The Good, The Bad, and The Disappointing (kubectl-ai)](/ai/kubernetes-ai-the-good-the-bad-and-the-disappointing-kubectl-ai)

I will make an assumption by saying that you work, in some capacity or another, with **Kubernetes** and that you are interested in making management of your clusters much easier, better, and faster with **AI**. If that's the case, I have a treat for you. We'll explore how to do just that. We'll take a look at an AI agent specialized in management of Kubernetes clusters. An agent that comes from the company that made Kubernetes. An agent that is open source. An agent that has the potential to be one of the most important tools in your toolbelt.

**[Full article >>](/ai/kubernetes-ai-the-good-the-bad-and-the-disappointing-kubectl-ai)**

---

<a href="/ai/from-shame-to-fame-how-i-fixed-my-lazy-vibe-coding-habits-with-taskmaster"><img src="/ai/from-shame-to-fame-how-i-fixed-my-lazy-vibe-coding-habits-with-taskmaster/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [From Shame to Fame: How I Fixed My Lazy Vibe Coding Habits with Taskmaster](/ai/from-shame-to-fame-how-i-fixed-my-lazy-vibe-coding-habits-with-taskmaster)

**AI does not work**, or, to be more precise, works poorly when trying to accomplish larger tasks that require many steps.

Imagine that we have a Product Requirements Document, or a PRD, that requires some major development, or a major refactoring. We might have spent hours or even days defining that PRD, and even more time defining all the tasks such a PRD should contain. Once we have it all set, we can start writing the code that implements that PRD, and that is likely to take even more time.

That situation presents one problem and one opportunity for improvement.

**[Full article >>](/ai/from-shame-to-fame-how-i-fixed-my-lazy-vibe-coding-habits-with-taskmaster)**

---

<a href="/internal-developer-platforms/forget-clis-and-guis-ai-is-the-new-interface-for-developer-platforms"><img src="/internal-developer-platforms/forget-clis-and-guis-ai-is-the-new-interface-for-developer-platforms/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [Forget CLIs and GUIs: AI is the New Interface for Developer Platforms](/internal-developer-platforms/forget-clis-and-guis-ai-is-the-new-interface-for-developer-platforms)

Most of the time, we, software engineers, are using AI to write code or get commands we might need to performs some operations. Today I want to do something different. I want to use AI to create user interface for an Internal Developer Platform.

Instead of telling users which button to click or which YAML to write or which command to execute, I want them to **interact with the platform through AI**.

**[Full article >>](/internal-developer-platforms/forget-clis-and-guis-ai-is-the-new-interface-for-developer-platforms)**

---

<a href="/ai/the-missing-link-how-mcp-servers-supercharge-your-ai-coding-assistant"><img src="/ai/the-missing-link-how-mcp-servers-supercharge-your-ai-coding-assistant/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [The Missing Link: How MCP Servers Supercharge Your AI Coding Assistant](/ai/the-missing-link-how-mcp-servers-supercharge-your-ai-coding-assistant)

We got Large Language Models (LLMs), but they were **not enough**. Then we got AI agents, but they were not enough either. Now we got Model Context Protocol (MCP).

Is that it? Is that what was needed to **make AI for software engineers truly useful?**

Let's see.

**[Full article >>](/ai/the-missing-link-how-mcp-servers-supercharge-your-ai-coding-assistant)**

---

<img src="/ai/outdated-ai-responses-context7-solves-llms-biggest-flaw/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Outdated AI Responses? Context7 Solves LLMs' Biggest Flaw](/ai/outdated-ai-responses-context7-solves-llms-biggest-flaw)

**LLMs are always behind**. They do not contain up to date information and examples for programming languages, libraries, tools, and whatever else we, software engineers, are using. Depending on the date an LLM was created, it might be days, weeks, or months behind. As such, examples will be using older libraries, outdated APIs, and deprecated versions of the tools.

Moreover, since LLMs are, in a way, databases of the whole Internet, they might give us code examples taken from places other than, for example, oficial documentation. They might give us generic answers that do not match versions we're working with.

We are going to fix that today in a very simple, yet effective way. We are going to **teach our agents how to get up to date information** they might need to come to the right conclusion and perform correct actions.

By the end of this post, the likelyhood of your AI agent doing the right thing will increase exponentially.

**[Full article >>](/ai/outdated-ai-responses-context7-solves-llms-biggest-flaw)**

---

<img src="/ai/claude-code-ai-agent-for-devops-sre-and-platform-engineering/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Claude Code: AI Agent for DevOps, SRE, and Platform Engineering](/ai/claude-code-ai-agent-for-devops-sre-and-platform-engineering)

If you are a software engineer, you are probably already using an AI agent like [GitHub Copilot](https://github.com/features/copilot), [Cursor](https://cursor.com), [Windsurf](https://windsurf.com), [Cline](https://cline.bot/) or something similar. If you are, you probably have an opinion which one of those is the best one out there. Or you might have been dissapointed with the results AI agents provide and chose to use none of them.

Today I'll tell you which one is **the best AI agent** for any type of software engineers, especially for those focused on operations. If you call yourself DevOps, or SRE, or Platform Engineer, you'll find out which one you should use.

Ready?

**[Full article >>](/ai/claude-code-ai-agent-for-devops-sre-and-platform-engineering)**

---

<img src="/infrastructure-as-code/aws-controllers-for-kubernetes-ack-is-it-worth-it/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [AWS Controllers for Kubernetes (ACK): Is It Worth It?](/infrastructure-as-code/aws-controllers-for-kubernetes-ack-is-it-worth-it)

It's not a secret that I believe in Kubernetes and that I think that it is much more than a "**thingy where we run containers**". It is an extensible API with controllers that can manage any type of resources. It is a **control plane** for everything.

That's why, a while ago, I was very excited when AWS Controllers for Kubernetes (ACK) project was born. It allows us to extend Kubernetes with Custom Resource Definitions and controllers that allow us to manage AWS resources through Kubernetes.

**[Full article >>](/infrastructure-as-code/aws-controllers-for-kubernetes-ack-is-it-worth-it)**

---

<img src="/kubernetes/kro-vs-helm-is-it-time-to-ditch-helm-charts/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Kro vs Helm: Is It Time to Ditch Helm Charts?](/kubernetes/kro-vs-helm-is-it-time-to-ditch-helm-charts)

During recent months I saw a lot of conversation and questions sparked by the release of kro, like the one in the picture. Many of them are related to comparison with Helm. Some people think that kro is, more or less, doing **the same** work as Helm. Others think that it is a **different syntax** that accomplishes the same result as Helm. Some are asking whether kro is a **replacement** for Helm.

There's hardly a day that I don't see a blog post or a Slack conversation or a question in Reddit around that subject.

I want to answer those questions today.

**[Full article >>](/kubernetes/kro-vs-helm-is-it-time-to-ditch-helm-charts)**

---

<img src="/development/mirrord-magic-write-code-locally-see-it-remotely/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Mirrord Magic: Write Code Locally, See It Remotely!](/development/mirrord-magic-write-code-locally-see-it-remotely)

Imagine this scenario.

There is a frontend application that talks to a backend which uses a database.

I am working on the code of that backend application.

I neither have nor care about the code of the frontend app and I do not have the database running locally. All I want is to write the code of that backend application and see the outcome of my work, either directly or through the frontend (the one that I am not running) and I want that local code to be connected to the database (which I am also not running).

**[Full article >>](/development/mirrord-magic-write-code-locally-see-it-remotely)**

---

<img src="/development/stop-using-docker-and-local-kubernetes-for-dev-environments-feat-okteto/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Stop Using Docker and Local Kubernetes for Dev Environments! (feat. Okteto)](/development/stop-using-docker-and-local-kubernetes-for-dev-environments-feat-okteto)

You are developing something. Everybody is, no matter whether that something is a user-facing application, infrastructure, or anything else.

While developing, you are trying to set up a development environment, probably locally since that's where your code is. You are likely trying to do all that using Docker or a local Kubernetes cluster like KinD.

If that's what you're doing, I'm here to tell you that you're doing it wrong.

**[Full article >>](/development/stop-using-docker-and-local-kubernetes-for-dev-environments-feat-okteto)**

---

<img src="/development/remote-environments-with-dev-containers-and-devpod-are-they-worth-it/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Remote Environments with Dev Containers and Devpod: Are They Worth It?](/development/remote-environments-with-dev-containers-and-devpod-are-they-worth-it)

Today we are going to explore running remote ephemeral development environments. We are going to see (potentially) the best solution you should (probably) NOT use. If that sounds confusing, you're not alone. 

We'll explore the Development Containers spec as well as Devpod as an implementation of that spec. Together, they provide a way to run ephemeral development environments.

There is a hidden reason for going through those. I have serious doubts about the story behind remote environments, at least in a specific form, and I want to discuss what we really want them for. But, to do that, we need to go through a few practical examples to be on the same page before I go off the beaten path and start questioning it all.

Buckle up. You're in for a ride that starts with some important questions that turn into excitement and finish... Well... I do not yet know how it will finish.

**[Full article >>](/development/remote-environments-with-dev-containers-and-devpod-are-they-worth-it)**
