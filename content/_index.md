+++
archetype = "home"
title = ""
+++

# Latest Posts

<!-- <a href="/ai/terminal-agents-codex-vs-crush-vs-opencode-vs-cursor-cli-vs-claude-code"><img src="/ai/terminal-agents-codex-vs-crush-vs-opencode-vs-cursor-cli-vs-claude-code/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [Terminal Agents: Codex vs. Crush vs. OpenCode vs. Cursor CLI vs. Claude Code](/ai/terminal-agents-codex-vs-crush-vs-opencode-vs-cursor-cli-vs-claude-code)

I love Claude Code. But I hate being locked into Anthropic models. What if I want to use GPT5? Or Llama? Or whatever comes out next week? So I went on a quest to find a good terminal-based coding agent that actually works with different models.

The perfect test case? GPT5. Everyone's hyping it as the best coding model ever created. If a terminal agent claims to be model-agnostic, it should work brilliantly with GPT5, right? So I tested every terminal-based agent I could find: Codex from OpenAI themselves, Charm Crush, OpenCode, Cursor CLI.

What I discovered might surprise you. By the end of this video, you'll understand exactly what's wrong with today's terminal agents, why model flexibility is harder than it seems, and whether any of these tools can actually compete with Claude Code. Let's find out.

**[Full article >>](/ai/terminal-agents-codex-vs-crush-vs-opencode-vs-cursor-cli-vs-claude-code)**

--- -->

<a href="/kubernetes/why-kubernetes-discovery-sucks-for-ai-and-how-vector-dbs-fix-it"><img src="/kubernetes/why-kubernetes-discovery-sucks-for-ai-and-how-vector-dbs-fix-it/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [Why Kubernetes Discovery Sucks for AI (And How Vector DBs Fix It)](/kubernetes/why-kubernetes-discovery-sucks-for-ai-and-how-vector-dbs-fix-it)

Kubernetes API is **brilliant for execution**. Once you know exactly which resources to deploy and how they work together, it handles everything flawlessly. Controllers reconcile state, resources get created, and your applications and infrastructure run perfectly.

But it **sucks big time for discovery**. When you need to figure out what's actually possible in your cluster, the API becomes a complete nightmare. You're stuck sifting through hundreds of cryptically named resource types, hoping to stumble across something that might solve your problem.

Even AI struggles with this. Ask it to "create a PostgreSQL database with schema management in AWS," and it either gives you a complex multi-resource approach or completely misses the simple solution that actually exists. The problem isn't missing information. **The problem is that the information is impossible to find**.

Today, I'll show you how **semantic search with vector databases** can finally solve this discovery nightmare. By the end of this video, you'll see how AI can instantly find the perfect resources using natural language, even when the exact keywords don't match.

**[Full article >>](/kubernetes/why-kubernetes-discovery-sucks-for-ai-and-how-vector-dbs-fix-it)**

---

<a href="/ai/stop-blaming-ai-vector-dbs-rag-game-changer"><img src="/ai/stop-blaming-ai-vector-dbs-rag-game-changer/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [Stop Blaming AI: Vector DBs + RAG = Game Changer](/ai/stop-blaming-ai-vector-dbs-rag-game-changer)

Let me guess. You tried AI, it hallucinated something completely wrong, and now you're back to doing everything manually while complaining that "AI doesn't work."

Maybe you're a developer who asked it about your codebase, and it confidently explained functions that don't exist. Or suggested using deprecated APIs your team abandoned two years ago. Perhaps it recommended architectural patterns that directly contradict your team's decisions.

Or you're in ops, and it gets even worse. You asked about your backup policies, and it invented procedures you've never implemented. You requested help with a Kubernetes deployment, and it suggested configurations that violate every security standard you have. You wanted it to troubleshoot a production issue, and it gave you generic advice that would take down your entire cluster.

**[Full article >>](/ai/stop-blaming-ai-vector-dbs-rag-game-changer)**

---

<a href="/ai/stop-wasting-time-turn-ai-prompts-into-production-code"><img src="/ai/stop-wasting-time-turn-ai-prompts-into-production-code/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [Stop Wasting Time: Turn AI Prompts Into Production Code](/ai/stop-wasting-time-turn-ai-prompts-into-production-code)

I spent three hours writing the perfect prompt. Three. Damn. Hours. And you know what? The AI still screwed it up. Not because the AI was bad, but because I was doing it completely wrong. I was treating prompts like throwaway commands when I should have been treating them like **production code**.

Here's what nobody tells you about AI prompts: they're not just instructions. They're **your team's collective knowledge**, encoded in a way that AI can execute. And if you're not treating them as first-class citizens in your codebase, you're wasting everyone's time. Today, I'm going to show you how to turn your prompts into a shared asset that evolves with your team, deploys like any other code, and actually makes AI useful instead of frustrating.

We'll start by understanding why context is everything in AI, then I'll show you the evolution of a real prompt from 5 words to 500, and finally reveal how MCP changes the entire game for prompt distribution. Let's dive in.

**[Full article >>](/ai/stop-wasting-time-turn-ai-prompts-into-production-code)**

---

<a href="/ai/ai-will-replace-coders---but-not-the-way-you-think"><img src="/ai/ai-will-replace-coders---but-not-the-way-you-think/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [AI Will Replace Coders - But Not the Way You Think](/ai/ai-will-replace-coders---but-not-the-way-you-think)

I've been in tech for over three decades, and **I've never seen developers this scared**. Not during the dot-com crash. Not during outsourcing waves. Not even during the layoffs. This time it's different because the threat isn't coming from other humans. It's coming from AI that can already write code faster than us. And here's what should really worry you: we're on a trajectory where soon it might write better code too.

But here's what pisses me off: **Everyone's panicking about the wrong thing**. They're worried AI will take their jobs because it can write code. That's like a chef worrying about losing their job because someone invented a better knife. You're missing the point entirely.

In this post, I'm going to tell you what your job actually is, why most developers have been doing it wrong for years, and how AI is about to expose that brutal reality. But I'll also show you exactly how to adapt, because those who get this right won't just survive. They'll thrive. And the questions I keep hearing prove that most people don't get it yet.

**[Full article >>](/ai/ai-will-replace-coders---but-not-the-way-you-think)**

---

<a href="/app-management/ai-meets-kubernetes-simplifying-developer-and-ops-collaboration"><img src="/app-management/ai-meets-kubernetes-simplifying-developer-and-ops-collaboration/thumbnail.jpg" style="width:50%; float:right; padding: 10px"></a>

## [AI Meets Kubernetes: Simplifying Developer and Ops Collaboration](/app-management/ai-meets-kubernetes-simplifying-developer-and-ops-collaboration)

Platform engineers face a tough challenge: **developers know what they need**, but they don't understand complex infrastructure. Platform engineers understand infrastructure, but they struggle to anticipate every developer requirement. The result? **Internal Developer Platforms** that miss the mark and platforms that require endless iterations to make them useful.

But what if there was a **third collaborator** that could bridge this gap? AI has vast technical knowledge but doesn't know your company's specific rules and constraints. However, when you combine developer intent, platform engineering expertise, and AI's technical knowledge, something powerful emerges.

I'm about to show you a working system that demonstrates this three-way collaboration. We'll watch developers express their needs in natural language, see AI translate those into deployments using platform engineering building blocks, and then I'll reveal the architecture that makes this possible.

**[Full article >>](/app-management/ai-meets-kubernetes-simplifying-developer-and-ops-collaboration)**

---

<a href="/ai/can-ai-replace-your-terraform-modules-infrastructures-new-future"><img src="/ai/can-ai-replace-your-terraform-modules-infrastructures-new-future/thumbnail-02-small.png" style="width:50%; float:right; padding: 10px"></a>

## [Can AI Replace Your Terraform Modules? Infrastructure's New Future](/ai/can-ai-replace-your-terraform-modules-infrastructures-new-future)

My AI agent just **failed** to create a database. It forgot the resource group, messed up the credentials, and made three attempts before getting it right.

But here's the plot twist: That's the **best** thing that could have happened.

Today, I'm going to show you why AI agents might make your carefully crafted golden paths **obsolete**. Why those Terraform modules or similar abstractions you spent months building might be holding AI back, and why letting AI fail and learn might be the future of infrastructure management.

**[Full article >>](/ai/can-ai-replace-your-terraform-modules-infrastructures-new-future)**
