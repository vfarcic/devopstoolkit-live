+++
archetype = "home"
title = ""
+++

# Latest Posts

<img src="/terminal/why-i-can-not-live-without-these-10-clis/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [10 CLIs I Can Not Live Without!](/terminal/why-i-can-not-live-without-these-10-clis)

Today we'll explore **ten CLI tools** without which my life would be meaningless. Well... Maybe not meaningless, but certainly much less productive and harder.

So, without further ado, those are tend CLIs I use on a daily basis, and you should use them as well.

**[Full article >>](/terminal/why-i-can-not-live-without-these-10-clis)**

---

<img src="/terminal/transform-your-terminal-3-must-have-zsh-plugins/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [Transform Your Terminal: 3 Must-Have Zsh Plugins!](/terminal/transform-your-terminal-3-must-have-zsh-plugins)

I use Zsh as my shell. It is the default shell in macOS and available in any other operating system. There's **no way I'll ever go back to Bash** and the only other Shell comparable to Zsh is Fish.

Fish is great, maybe even better than Zsh, but it's **not POSIX compliant** meaning that some of the commands I would use in Fish might not work elsewhere. Zsh, on the other hand, is POSIX compliant meaning that whatever I do in it would work in any other Shell, except Fish. Compatibility wins.

All in all, Zsh is great and I love it. However, Zsh alone is... well, it's **just a shell**. We need to extend it to make it truly great.

Specifically, there are **three must-have plugins**. With those we'll explore today, Zsh gets transformed from "yet another shell" to "I can't live without it".

Here it goes. Here are the three must-have Zsh plugins that will transform the way you work.

**[Full article >>](/terminal/transform-your-terminal-3-must-have-zsh-plugins)**

---

<img src="/terminal/from-boring-to-productive-customize-your-shell-prompt-with-starship/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [From Boring to Productive: Customize Your Shell Prompt with Starship](/terminal/from-boring-to-productive-customize-your-shell-prompt-with-starship)

What I'm about to say might sound silly, but I'm going to say it anyway.

One of the easiest ways to improve productivity is by having a **good Shell prompt**.

I, for example, tend to have a minimal prompt that shows only the pending actions I need to perform.

> Do NOT try to execute the commands in this section. We'll go through the setup and details in the next sections. This is only the preview of what's comming.

```
dotfiles-demo 
âžœ 
```

That means that, most of the time, the only information shown in my prompt is the current directory which, in this case, is `dotfiles-demo`. It is a boring prompt, by design.

However, let's see what happens if...

**[Full article >>](/terminal/from-boring-to-productive-customize-your-shell-prompt-with-starship)**

---

<img src="/ci-cd/gitops-broke-ci-cd-here-is-how-to-fix-it-with-argo-events/thumbnail.jpg" style="width:50%; float:right; padding: 10px">

## [GitOps Broke CI/CD! Here is How to Fix It With Argo Events](/ci-cd/gitops-broke-ci-cd-here-is-how-to-fix-it-with-argo-events)

**GitOps is amazing**, especially for those using Kubernetes. Yet, GitOps poses significant problems when it comes to execution of tasks that should be performed after deployments. For example, we cannot run functional tests through workflows or pipelines like GitHub Actions or Jenkins. **GitOps broke CI/CD processes**, and we need to fix that.

Let me explain.

**[Full article >>](/ci-cd/gitops-broke-ci-cd-here-is-how-to-fix-it-with-argo-events)**

---

<img src="/ci-cd/if-dockerfile-and-makefile-had-a-baby-earthly-and-earthfile/thumbnail.png" style="width:50%; float:right; padding: 10px">

## [If Dockerfile and Makefile Had a Baby... Earthly and Earthfile](/ci-cd/if-dockerfile-and-makefile-had-a-baby-earthly-and-earthfile)

**Makefile** walks into a bar and notices **Dockerfile** sitting alone. She joins him, they talk, they flirt...

> The rest of that story has been censored. You'll have to fill in the gaps using your imagination.

...a baby was born, and that baby was named **Earthfile**.

**[Full article >>](/ci-cd/if-dockerfile-and-makefile-had-a-baby-earthly-and-earthfile)**

---

<img src="/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler/thumbnail.png" style="width:50%; float:right; padding: 10px">

## [Scaling Explained Through Kubernetes HPA, VPA, KEDA & Cluster Autoscaler](/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler)

Scaling is probably one of the most important aspects of computing, and a common cause of bankrupcy.

If our processes use more memory and CPU than what they need, they are wasting money or "stealing" those resources from others thus making them less efficient. On the other hand,if we give processes less memory and CPU than what they need, their performance will be affected negatively making user experience suck. And that's the good outcome. Much worse situation is that underpowered processes might crash with "out of memory" and other similar exceptions.

Hence, the goal is to assign just the right amount of resources to processes. Not too much, not to few, but just right. We do that through scaling, and we need to answer three questions.

* **What do we scale?**
* **Where do we scale?**
* **Who scales?**

**[Full article >>](/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler)**
