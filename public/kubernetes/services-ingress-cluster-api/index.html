<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.125.4">
    <meta name="generator" content="Relearn 6.0.0+tip">
    <meta name="description" content=" In the Mastering Kubernetes: Dive into Workloads APIs video we explored Kubernetes Workload APIs. We saw the differences between Pods, ReplicaSets, Jobs, Deployments, StatefulSets, DaemonSets, and CronJobs.
When I asked whether it would be interesting to explore another set of Kubernetes APIs, you overwhelmed me with responses that all say â€œYes. Do more!â€ So, today we will continue where we left.">
    <meta name="author" content="Viktor Farcic">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="http://localhost:1313/kubernetes/services-ingress-cluster-api/thumbnail.jpeg">
    <meta name="twitter:title" content="Mastering Kubernetes: Dive into Service and Network APIs">
    <meta name="twitter:description" content=" In the Mastering Kubernetes: Dive into Workloads APIs video we explored Kubernetes Workload APIs. We saw the differences between Pods, ReplicaSets, Jobs, Deployments, StatefulSets, DaemonSets, and CronJobs.
When I asked whether it would be interesting to explore another set of Kubernetes APIs, you overwhelmed me with responses that all say â€œYes. Do more!â€ So, today we will continue where we left.">
    <meta property="og:url" content="http://localhost:1313/kubernetes/services-ingress-cluster-api/index.html">
    <meta property="og:title" content="Mastering Kubernetes: Dive into Service and Network APIs">
    <meta property="og:description" content=" In the Mastering Kubernetes: Dive into Workloads APIs video we explored Kubernetes Workload APIs. We saw the differences between Pods, ReplicaSets, Jobs, Deployments, StatefulSets, DaemonSets, and CronJobs.
When I asked whether it would be interesting to explore another set of Kubernetes APIs, you overwhelmed me with responses that all say â€œYes. Do more!â€ So, today we will continue where we left.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="http://localhost:1313/kubernetes/services-ingress-cluster-api/thumbnail.jpeg">
    <meta itemprop="name" content="Mastering Kubernetes: Dive into Service and Network APIs">
    <meta itemprop="description" content=" In the Mastering Kubernetes: Dive into Workloads APIs video we explored Kubernetes Workload APIs. We saw the differences between Pods, ReplicaSets, Jobs, Deployments, StatefulSets, DaemonSets, and CronJobs.
When I asked whether it would be interesting to explore another set of Kubernetes APIs, you overwhelmed me with responses that all say â€œYes. Do more!â€ So, today we will continue where we left.">
    <meta itemprop="datePublished" content="2024-05-13T16:00:00+00:00">
    <meta itemprop="dateModified" content="2024-05-13T16:00:00+00:00">
    <meta itemprop="wordCount" content="5319">
    <meta itemprop="image" content="http://localhost:1313/kubernetes/services-ingress-cluster-api/thumbnail.jpeg">
    <title>Mastering Kubernetes: Dive into Service and Network APIs</title>
    <link href="/kubernetes/services-ingress-cluster-api/index.xml" rel="alternate" type="application/rss+xml" title="Mastering Kubernetes: Dive into Service and Network APIs">
    <link href="/css/fontawesome-all.min.css?1721771712" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fontawesome-all.min.css?1721771712" rel="stylesheet"></noscript>
    <link href="/css/nucleus.css?1721771712" rel="stylesheet">
    <link href="/css/auto-complete.css?1721771712" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/auto-complete.css?1721771712" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar.min.css?1721771712" rel="stylesheet">
    <link href="/css/fonts.css?1721771712" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fonts.css?1721771712" rel="stylesheet"></noscript>
    <link href="/css/theme.css?1721771712" rel="stylesheet">
    <link href="/css/theme-dot.css?1721771712" rel="stylesheet" id="R-variant-style">
    <link href="/css/chroma-relearn-dark.css?1721771712" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/css/variant.css?1721771712" rel="stylesheet">
    <link href="/css/print.css?1721771712" rel="stylesheet" media="print">
    <script src="/js/variant.js?1721771712"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='http:\/\/localhost:1313';
      // variant stuff
      window.variants && variants.init( [ 'dot' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>

  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-2NXCC9XM9Y"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-2NXCC9XM9Y');
        }
      </script>
    
  


  </head>
  <body class="mobile-support html" data-url="/kubernetes/services-ingress-cluster-api/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"><nav class="TableOfContents">
  <ul>
    <li><a href="#setup">Setup</a></li>
    <li><a href="#kubernetes-without-services">Kubernetes Without Services</a></li>
    <li><a href="#kubernetes-services-with-clusterip">Kubernetes Services with ClusterIP</a></li>
    <li><a href="#kubernetes-services-with-nodeport">Kubernetes Services with NodePort</a></li>
    <li><a href="#kubernetes-services-with-loadbalancer">Kubernetes Services with LoadBalancer</a></li>
    <li><a href="#kubernetes-ingress">Kubernetes Ingress</a></li>
    <li><a href="#kubernetes-gateway-api">Kubernetes Gateway API</a></li>
    <li><a href="#goodbye-for-now">Goodbye (For Now)</a></li>
    <li><a href="#destroy">Destroy</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="/kubernetes/index.html"><span itemprop="name">Kubernetes</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Mastering Kubernetes: Dive into Service and Network APIs</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler/index.html" title="Scaling Explained Through Kubernetes HPA, VPA, KEDA &amp; Cluster Autoscaler (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/kubernetes/clusterpedia/index.html" title="Single Pane of Glass for Kubernetes Clusters with Clusterpedia (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="mastering-kubernetes-dive-into-service-and-network-apis">Mastering Kubernetes: Dive into Service and Network APIs</h1>

<img src="/logo/kubernetes.png" style="width:40%; float:right; padding: 10px">
<p>In the <a href="https://youtu.be/U6weXlzQxoY" rel="external" target="_blank">Mastering Kubernetes: Dive into Workloads APIs</a> video we explored Kubernetes <strong>Workload APIs</strong>. We saw the differences between <strong>Pods</strong>, <strong>ReplicaSets</strong>, <strong>Jobs</strong>, <strong>Deployments</strong>, <strong>StatefulSets</strong>, <strong>DaemonSets</strong>, and <strong>CronJobs</strong>.</p>
<p>When I asked whether it would be interesting to explore another set of Kubernetes APIs, you overwhelmed me with responses that all say &ldquo;<strong>Yes. Do more!</strong>&rdquo; So, today we will continue where we left.</p>
    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/-1H0BeN9hIk?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>We&rsquo;ll explore Kubernetes <strong>Service APIs</strong>. We&rsquo;ll see what <strong>Services</strong> are and what the difference is between <strong>ClusterIP</strong>, <strong>NodePort</strong>, and <strong>LoadBalancer</strong> types. From there on, we&rsquo;ll explore <strong>Ingress</strong> and <strong>Gateway API</strong>.</p>
<p>We&rsquo;ll see what is the purpose of each, when each of them should or should not be used for, and quite a few things.</p>
<p>Those should give you a pretty good understanding of Kubernetes networking, at least on the basic level from which you might want to jump into more advanced APIs like those associated with a service mesh.</p>
<p>Buckle up! We&rsquo;re about to dive into all Kubernetes Service and Network APIs.</p>
<h2 id="setup">Setup</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/vfarcic/kubernetes-demo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cd kubernetes-demo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git pull
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git checkout services</span></span></code></pre></div><blockquote>
<p>Watch <a href="https://youtu.be/WiFLtcBvGMU" rel="external" target="_blank">Nix for Everyone: Unleash Devbox for Simplified Development</a> if you are not familiar with Devbox. Alternatively, you can skip Devbox and install all the tools listed in <code>devbox.json</code> yourself.</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>devbox shell</span></span></code></pre></div><blockquote>
<p>Demo setup is based on Google Cloud GKE. If you prefer a different Kubernetes cluster, skip <code>gcloud</code> commands and ensure that your cluster has Gateway API setup.</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gcloud auth login
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export USE_GKE_GCLOUD_AUTH_PLUGIN<span style="color:#f92672">=</span>True
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export PROJECT_ID<span style="color:#f92672">=</span>dot-<span style="color:#66d9ef">$(</span>date +%Y%m%d%H%M%S<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcloud projects create $PROJECT_ID
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;https://console.cloud.google.com/marketplace/product/google/container.googleapis.com?project=</span>$PROJECT_ID<span style="color:#e6db74">&#34;</span></span></span></code></pre></div><blockquote>
<p>Open the URL from the output and enable the Kubernetes API</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export KUBECONFIG<span style="color:#f92672">=</span>$PWD/kubeconfig.yaml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcloud container clusters create dot --project $PROJECT_ID <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --zone us-east1-b --machine-type e2-standard-4 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --num-nodes <span style="color:#ae81ff">2</span> --no-enable-autoupgrade --gateway-api standard
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcloud compute firewall-rules create silly-demo-node-port <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --allow tcp:30000 --project $PROJECT_ID
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kubectl create namespace a-team
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kubectl --namespace a-team apply --filename deployment/base.yaml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kubectl create namespace b-team</span></span></code></pre></div><h2 id="kubernetes-without-services">Kubernetes Without Services</h2>
<p>Containers in Kubernetes are wrapped inside Pods. Each Pod gets an IP assigned to it and that means that we can use that IP to comminicate with a specific Pod.</p>
<p>Let me show you what I mean by that by listing Pods inside one of my Namespaces.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get pods</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME                          READY   STATUS    RESTARTS   AGE
silly-demo-54757f9885-g2ghq   1/1     Running   0          5s
silly-demo-54757f9885-q62fk   1/1     Running   0          5s</code></pre></div><p>There are two Pods and if we output them as YAML&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get pod --output yaml | yq .</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">items</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">status</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">...</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">hostIP</span>: <span style="color:#ae81ff">10.142.0.14</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">phase</span>: <span style="color:#ae81ff">Running</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">podIP</span>: <span style="color:#ae81ff">10.124.0.8</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">podIPs</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">ip</span>: <span style="color:#ae81ff">10.124.0.8</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">qosClass</span>: <span style="color:#ae81ff">Burstable</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">startTime</span>: <span style="color:#e6db74">&#34;2024-04-16T19:46:38Z&#34;</span></span></span></code></pre></div><p>&hellip;we can see the IP assigned to it (<code>podIPs</code>).</p>
<p>That is very similar to how servers and virtual machines work. Back in the days when we were deploying applications directly to servers, we would use their IPs to communicate with processes inside it.</p>
<img src="diag-01.png" style="width:70%; float:right; padding: 10px">
<p>If application A would need to talk to application B running in a different server, we would instruct it to talk to the IP of that server. Easy. Right?</p>
<p>Well&hellip; That was never a great idea, but it wasn&rsquo;t a horrible one either. You see, back in those days, virtual machines and, especially servers were relatively static. That server where an application is running is likely going to continue existing for a while. That IP will be the endpoint for that application until that server eventually dies. We were placing our bets that it would never die. It would live forever.</p>
<p>In the meantime, we got tools that could do service discovery so that application A would be able to talk to the application B simply by knowing it&rsquo;s name. Service discovery would figure out where it is and how to translate that name into one or more IPs. If the server goes down and we move the application to a different one, service discovery would figure it out and start forwarding requests to that new server.</p>
<p>The lesson learned is that we should never use IPs directly but, instead, rely on service discovery to figure out what is where.</p>
<p>That&rsquo;s why those IPs assigned to those Pods are useless as a way of direct communication. Pods are created and destroyed all the time. They are moved from one node to another. They are scaled up and down. Pods are not static. They are changing all the time. Hence, whichever IP is assigned to a Pod is likely to become invalid pretty soon. We need something more. We need some sort of service discovery. That&rsquo;s what Kubernetes Services are for.</p>
<p>There are a few types of Services. We&rsquo;ll start with the least capable one.</p>
<h2 id="kubernetes-services-with-clusterip">Kubernetes Services with ClusterIP</h2>
<p>Let&rsquo;s take a look at a Service type ClusterIP.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/base.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">ClusterIP</span></span></span></code></pre></div><p>This is a relatively simple definition of a <code>Service</code>. It has a list of <code>ports</code> with only one entry. It uses <code>TCP</code> protocol to receive requests on the <code>port: 8080</code> and forward them to the <code>targetPort: 8080</code>. It assumes that one of the processes in a container is listening to that port.</p>
<p>Further on, we have the <code>selector</code> which, in this case, points to the <code>name</code> label set to <code>silly-demo</code>. That means that requests will be forwarded to all the Pods with that label running in the same Namespace.</p>
<p>The last entry is important. It has the <code>type</code> set to <code>ClusterIP</code>. That means that only other Pods in the same cluster will be able to use that <code>Service</code> to communicate with matching Pods. We will NOT be able to use it for traffic coming from outside the cluster. None of our users will be able to access those Pods directly. It is meant to serve only internal users which are probably other Pods.</p>
<p>Let&rsquo;s apply that manifest&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply --filename service/base.yaml</span></span></code></pre></div><p>&hellip;and list all the Services.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get services</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
silly-demo   ClusterIP   10.95.55.206   &lt;none&gt;        8080/TCP   5s</code></pre></div><p>For now, remember that the name of that Service is <code>silly-demo</code> and that it is associated with some Pods. The <code>EXTERNAL-IP</code> is set to <code>&lt;none&gt;</code> meaning that it is not accessible from outside the cluster.</p>
<p>How can we use it to communicate to those Pods from inside the same cluster? The answer to that question is simple. We just need to know the name of the Service and, sometimes, also the Namespace where it&rsquo;s running.</p>
<p>Let me demonstrate by creating another Pod inside the same Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team run curl <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --image curlimages/curl:8.7.1 --stdin --tty --rm <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -- sh</span></span></code></pre></div><p>This is a pretty &ldquo;dumb&rdquo; Pod that has a container that is incapable of doing anything but sending requests through <code>curl</code>. That&rsquo;s all we need.</p>
<p>We&rsquo;ll send five requests to the application silly-demo.</p>
<p>The first will calculate Fibonacci number 5,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080/fibonacci?number<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span></span></span></code></pre></div><p>&hellip;the second will go with number 10,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080/fibonacci?number<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span></span></span></code></pre></div><p>&hellip;then goes the third,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080/fibonacci?number<span style="color:#f92672">=</span><span style="color:#ae81ff">15</span></span></span></code></pre></div><p>&hellip;the fourth,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080/fibonacci?number<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span></span></span></code></pre></div><p>&hellip;and the fifth.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080/fibonacci?number<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span></span></span></code></pre></div><p>The important note here is that all those requests were sent to a non-existing domain silly-demo that happens to be the name of the Service we applied. We have no idea where the Pods are, how many of them are there, or anything else. All we needed is the name of the Service and the port.</p>
<p>Given that all the requests received responses, it is clea that those requests somehow reached at least one of those Pods. The question is which one processed those requests.</p>
<p>Let&rsquo;s <code>exit</code> the temporary Pod&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>exit</span></span></code></pre></div><p>&hellip;and list all the Pods left in that Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get pods</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME                          READY   STATUS    RESTARTS   AGE
silly-demo-54757f9885-g2ghq   1/1     Running   0          4m35s
silly-demo-54757f9885-q62fk   1/1     Running   0          4m35s</code></pre></div><p>We can try to deduce which of those two Pods received those requests by taking a look at the logs.</p>
<p>Let&rsquo;s take a look at the logs from one of those Pods and filter them by the word <code>fibonacci</code>.</p>
<blockquote>
<p>Replace <code>[...]</code> with the <code>NAME</code> of the first Pod</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team logs <span style="color:#f92672">[</span>...<span style="color:#f92672">]</span> | grep fibonacci</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>2024/04/16 19:50:37 DEBUG Handling request URI=&#34;/fibonacci?number=5&#34;
2024/04/16 19:50:42 DEBUG Handling request URI=&#34;/fibonacci?number=10&#34;
2024/04/16 19:50:45 DEBUG Handling request URI=&#34;/fibonacci?number=20&#34;
2024/04/16 19:50:49 DEBUG Handling request URI=&#34;/fibonacci?number=25&#34;</code></pre></div><p>We can see that only some of those five requests reached that Pod, meaning that the rest went to the other one.</p>
<p>Here&rsquo;s what&rsquo;s happening.</p>
<img src="diag-02.png" style="width:70%; float:right; padding: 10px">
<p>A Service is associated with a number of Pods. That number can be zero, or one, or two, or three, or any other number. Most of the time those are different replicas of the same application. Technically it could be even Pods of different applications but that would not make much sense so I&rsquo;ll ignore that scenario.</p>
<p>So, there is a Service associated with a number of replicas of an application.</p>
<p>Since that Service type is set to <code>ClusterIP</code>, it can receive requests only from inside the cluster. Today that is a different Pod.</p>
<p>So, a Pod sends a request to the Service which forwards it to one of the replicas associated with it. Internally, a DNS that equals service name is created for each service. So, that request did not need to know anything but the name of the service. The service, on the other hand, knows the IPs of all the associated Pods and it uses round robin algorythm which can be described as &ldquo;distribute requests evenly across all replicas&rdquo;. So if there are 3 target Pods and we send 300 requests to the service, each of those Pods will receive approximately 100 requests.</p>
<p>Now, let&rsquo;s try to do the same but from a different Namespace.</p>
<p>So, start a Pod with a container based on the <code>curl</code> image,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace b-team run curl <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --image curlimages/curl:8.7.1 --stdin --tty --rm <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -- sh</span></span></code></pre></div><p>&hellip;and send a request to <code>silly-demo</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo:8080</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>curl: Could not resolve host: silly-demo</code></pre></div><p>That failed, miserably.</p>
<p>Here&rsquo;s the thing. A service, or any other resource type, must have a unique name within a Namespace. We cannot have two silly-demo Services in the same Namespace. What we can have are two silly-demo Services in different Namespaces.</p>
<p>So, Kubernetes assumes that if we reference a service with only its name, that service is in the same Namespace as the Pod trying to communicate with it. The curl Pod we just used was running in the b-team Namespace while the Service it tried to talk to is in the a-team Namespace. To overcome that, we need to add the Namespace to the address we&rsquo;re trying to talk to.</p>
<p>So, we can construct the URL by specifying the name of the service (<code>silly-demo</code>) as a subdomain of the Namespace (<code>a-team</code>).</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl http://silly-demo.a-team:8080</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>This is a silly demo</code></pre></div><p>That worked. Huray!</p>
<p>Let&rsquo;s exit the <code>curl</code> Pod&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>exit</span></span></code></pre></div><p>&hellip;and explore a different type of Services.</p>
<h2 id="kubernetes-services-with-nodeport">Kubernetes Services with NodePort</h2>
<p>Let&rsquo;s take a look at a variation of the Service we explored earlier.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/node-port.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">nodePort</span>: <span style="color:#ae81ff">30000</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">NodePort</span></span></span></code></pre></div><p>This time, the <code>type</code> of the Service is <code>NodePort</code>. That means that it will be available outside of the cluster. A port will be opened on all nodes of the cluster so we should be able to send a request to any node, any VM, of the cluster and that request will find its way to one of the Pods associated with that Service.</p>
<p>Now, if the only change would be the type of the Service, Kubernetes would expose it to the outside world by assigning it a random port and we would need to &ldquo;discover&rdquo; which port was assigned. As an alternative, we can specify which port will be opened on all nodes of the cluster by specifying <code>nodePort</code> to be, in this case, <code>30000</code>.</p>
<p>Bear in mind that specifying a specific nodePort is not a good idea. If another Service would expose itself through the same port, we would have a conflict. If we have to expose Services like that, we are better of letting Kubernetes expose it through a random port. We&rsquo;ll see that in action later. For now, we hard-coded port 30000 mostly for simplicity reasons, and not as something I recommend you to do.</p>
<p>Now, let&rsquo;s apply the change to the Service,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --filename service/node-port.yaml</span></span></code></pre></div><p>&hellip;and retrieve all the Services from that Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get services</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME         TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
silly-demo   NodePort   10.95.55.206   &lt;none&gt;        8080:30000/TCP   4m58s</code></pre></div><p>We can see that, this time, the port <code>8080</code> is now exposed through the port <code>30000</code>.</p>
<p>To confirm that NodePort indeed means what I said it does, first we&rsquo;ll find an IP of one of the nodes of the cluster. It can be any, so we&rsquo;ll use the first one (<code>[0]</code>).</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get nodes <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --output jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{.items[0].status.addresses}&#34;</span> | jq .</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>[
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;address&#34;</span>: <span style="color:#e6db74">&#34;10.142.0.14&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;InternalIP&#34;</span>
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;address&#34;</span>: <span style="color:#e6db74">&#34;35.231.232.6&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;ExternalIP&#34;</span>
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;address&#34;</span>: <span style="color:#e6db74">&#34;gke-dot-default-pool-3e9e609d-5s3n&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;Hostname&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>]</span></span></code></pre></div><p>The <code>ExternalIP</code> is the one we&rsquo;re looking for. That&rsquo;s the IP of one of the worked nodes of the cluster.</p>
<p>So, let&rsquo;s send a request to the external IP of one of the nodes and the port we chose to expose (<code>30000</code>).</p>
<blockquote>
<p>Replace <code>[...]</code> with the <code>ExternalIP</code> address.</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl <span style="color:#e6db74">&#34;http://[...]:30000&#34;</span></span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>This is a silly demo</code></pre></div><p>That worked. We got a response from one of the Pods associated with the Service.</p>
<p>Here&rsquo;s what we did and what happened.</p>
<img src="diag-03.png" style="width:70%; float:right; padding: 10px">
<p>We have a Service associated with a number of Pods. The Service type is set to NodePort meaning that it exposes a port, in this case 30000, on every single node of the cluster.</p>
<p>We sent a request to one of the nodes of the cluster. The Service picked that request and forwarded it to one of the Pods associated with it. That Pod could be running physically on any of the nodes. The Pod responded and that response eventually got back to us.</p>
<p>An important note here is that Services set to be type NodePort inherit all the features of ClusterIP Services so we can still have Pods inside the cluster communicating with the Pods associated with that Service in the same way as before.</p>
<p>Here&rsquo;s an important note. If you are using a managed Kubernetes in Cloud like, for example, Google GKE, AWS EKS, or Azure AKS, you might never use NodePort services, at least not in the form we just explained. You&rsquo;ll use something better.</p>
<p>That being said, let&rsquo;s remove the Service we just applied&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team delete <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --filename service/node-port.yaml</span></span></code></pre></div><p>&hellip;and see what that something is.</p>
<h2 id="kubernetes-services-with-loadbalancer">Kubernetes Services with LoadBalancer</h2>
<p>The problem with NodePort services is that it is silly to rely on sending requests directly to a specific node of a cluster. That would fail the moment stops working, be it because it went down due to some unexpected event or upagrade or any other reason.</p>
<p>A much better solution would be to have some sort of a proxy or a load balancer that would always contain an up-to-date list of nodes and forward requests to whichever is healthy. The problem is that such a solution might be challenging to build on our own. Luckily, we don&rsquo;t have to build anything like that ourselves. Kubernetes already has that capability and all we have to do is change the Service to LoadBalancer.</p>
<p>Let&rsquo;s take a look at an example.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/load-balancer.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">LoadBalancer</span></span></span></code></pre></div><p>This is almost the same definition as the first one we saw, except that the <code>type</code> is now set to <code>LoadBalancer</code>.</p>
<p>Just as NodePort Services inherit all the features of ClusterIP, and add the ability to expose a port on all the nodes, LoadBalancer services inherit everything NodePort services do, and than some.</p>
<p>That means that the LoadBalancer Services also open ports on all the nodes. However, since, in this case, we did not specify the nodePort, that port will be auto-generated.</p>
<p>On top of doing all the same things as NodePort, LoadBalancer Services also create external load balancers and configure them to talk to whichever ports are exposed.</p>
<p>Let&rsquo;s apply that definition,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --filename service/load-balancer.yaml</span></span></code></pre></div><p>&hellip;and retrieve the Services in that Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get services</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME         TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)          AGE
silly-demo   LoadBalancer   10.95.50.22   &lt;pending&gt;     8080:32342/TCP   6s</code></pre></div><p>As expected, the Service mapped a port on a node (<code>32342</code>) to the port the processes in containers listen to. That&rsquo;s not new. The <code>EXTERNAL-IP</code> being in the <code>&lt;pending&gt;</code> mode is new.</p>
<p>Right now, the Service instructed the provider, in this case Google Cloud to create a new load balancer. Once the load balancer is created, it will configure it to listen to the port <code>8080</code> and forward requests to the service through the node port. From there on, the service itself will forward requests to associated Pods.</p>
<p>Let&rsquo;s wait for a moment&hellip; and retrieve the service again.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get services</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME         TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)          AGE
silly-demo   LoadBalancer   10.95.50.22   34.75.165.181   8080:30797/TCP   117s</code></pre></div><p>We can see that the <code>EXTERNAL-IP</code> now contains an address. That&rsquo;s the IP of the load balancer which we could use to configure a DNS, a domain, so that requests sent to it are redirected to the load balancer. In turn, load balancer contains the list of the IPs of all the healthy nodes. If a node goes down, its IP will be removed from the list load balancer is using to forward requests.</p>
<p>Here&rsquo;s the proof.</p>
<p>I&rsquo;ll copy the external IP, the one of the load balancer, and use it to send a request.</p>
<blockquote>
<p>Replace <code>[...]</code> with the <code>EXTERNAL-IP</code></p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl <span style="color:#e6db74">&#34;http://[...]:8080&#34;</span></span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>This is a silly demo</code></pre></div><p>We can see that we got the usual response from one of the Pods. It worked and we did not need to resolve to using IP of any specific node of the cluster.</p>
<p>Here&rsquo;s what we did and what happened.</p>
<img src="diag-04.png" style="width:70%; float:right; padding: 10px">
<p>We created a LoadBalancer Service which, in turn, instructed the provider to create an external load balancer which always has up-to-date information about worker nodes of the cluster. If a node goes down, that node will be removed from the list so requests sent to the load balancer will always be forwarded to one of the healthy nodes.</p>
<p>That load balancer was automatically configured to accept requests on port 8080 and forward them to whichever autogenerated port was exposed on all nodes of the cluster.</p>
<p>Once those requests enter nodes, the Service itself redirects them to associated Pods.</p>
<p>Now, you might think that&rsquo;s it. That&rsquo;s how we expose our applications to outside world. Right? Well&hellip; Not so fast. Having LoadBalancer Services alone would mean that we would need a service for each application and that would produce too many load balancers and would cause us to go crazy when configuring DNSes. We need more. We need Ingress controllers.</p>
<h2 id="kubernetes-ingress">Kubernetes Ingress</h2>
<p>Before we start exploring Ingress, we&rsquo;ll go back to the begining with our Service.</p>
<p>As a reminder, this is what we started with.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/base.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">ClusterIP</span></span></span></code></pre></div><p>It is a <code>ClusterIP</code> Service and all the services you will write will be of that type. As you will see soon, there is no need for you to expose ports through NodePort or to create load balancers. Most of the time, if not always, all your services should be accessible only from inside the cluster.</p>
<p>I know. That might sound confusing. I&rsquo;ll explain why in a moment, right after we apply the ClusterIP Service.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply --filename service/base.yaml</span></span></code></pre></div><p>We&rsquo;ll use an Ingress controller to do all the work required for requests to reach our Services.</p>
<p><a href="#R-image-ff295f99485ecf52053d868c7eadee63" class="lightbox-link"><img class="noborder inline lazy lightbox noshadow figure-image" loading="lazy" src="/logo/nginx.svg?height=8vw&classes=inline" style=" height: 8vw; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff295f99485ecf52053d868c7eadee63"><img class="noborder inline lazy lightbox noshadow lightbox-image" loading="lazy" src="/logo/nginx.svg?height=8vw&classes=inline"></a>
<a href="#R-image-459e5dbf4fb98ad7669789c54b03a3bb" class="lightbox-link"><img class="noborder inline lazy lightbox noshadow figure-image" loading="lazy" src="/logo/contour.svg?height=8vw&classes=inline" style=" height: 8vw; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-459e5dbf4fb98ad7669789c54b03a3bb"><img class="noborder inline lazy lightbox noshadow lightbox-image" loading="lazy" src="/logo/contour.svg?height=8vw&classes=inline"></a>
<a href="#R-image-c155d7de3336abed59f5f51706e11b5d" class="lightbox-link"><img class="noborder inline lazy lightbox noshadow figure-image" loading="lazy" src="/logo/kong.png?height=8vw&classes=inline" style=" height: 8vw; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c155d7de3336abed59f5f51706e11b5d"><img class="noborder inline lazy lightbox noshadow lightbox-image" loading="lazy" src="/logo/kong.png?height=8vw&classes=inline"></a>
<a href="#R-image-f2c3e21666b67ac0f0f5984cea161cc3" class="lightbox-link"><img class="noborder inline lazy lightbox noshadow figure-image" loading="lazy" src="/logo/traefik.png?height=8vw&classes=inline" style=" height: 8vw; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f2c3e21666b67ac0f0f5984cea161cc3"><img class="noborder inline lazy lightbox noshadow lightbox-image" loading="lazy" src="/logo/traefik.png?height=8vw&classes=inline"></a></p>
<p>Now, unlike Services themselves, Ingress is not available in Kubernetes out-of-the-box. Ingress specification is there, but Kubernetes does not come with an implementation of that spec. We need to pick one out of many. It could be NGINX Ingress, or Contour, or Kong, or any other. There are many and it would take too much time to go through the pros and cons of all of them. Instead, we&rsquo;ll just install one I picked, and that one is Traefik.</p>
<p>The installation is simple with <code>helm upgrade --install</code>, name, repo, and Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>helm upgrade --install traefik traefik <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --repo https://helm.traefik.io/traefik <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --namespace traefik --create-namespace --wait</span></span></code></pre></div><p>Let&rsquo;s take a look at the Services in the <code>traefik</code> Namespace.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace traefik get services</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME      TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)                      AGE
traefik   LoadBalancer   10.95.49.105   35.185.11.184   80:31820/TCP,443:31323/TCP   47s</code></pre></div><p>Traefik created a <code>LoadBalancer</code> service exposing internal port <code>80</code> for HTTP and <code>443</code> for HTTPS. Those ports were exposed on nodes as random ports, and that&rsquo;s okay since, as we already saw, the external load balancer will automatically map to those.</p>
<p>Normally, we would take the <code>EXTERNAL-IP</code> and map DNSes of our domains to it. We won&rsquo;t do that today, if for no other reason, then because I don&rsquo;t have a spare unused domain. We&rsquo;ll use something else. I&rsquo;ll get to that. For now, I&rsquo;ll take that IP and store it in an environment variable. That way I can pretend that I&rsquo;m not an old fart who cannot memorize a few numbers.</p>
<blockquote>
<p>Replace <code>[...]</code> with the <code>EXTERNAL-IP</code></p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export EXTERNAL_IP<span style="color:#f92672">=[</span>...<span style="color:#f92672">]</span></span></span></code></pre></div><p>Since Kubernetes only provides a specification but not an implementation of an Ingress, we need to know the name of the Ingress class, especially since a single claster might install multiple ingresses. That rarely makes sense, but there is that option if you choose to go &ldquo;crazy&rdquo;.</p>
<p>Anyways&hellip; We can see which Ingresses are available by outputting <code>ingressclasses</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get ingressclasses</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME      CONTROLLER                      PARAMETERS   AGE
traefik   traefik.io/ingress-controller   &lt;none&gt;       70s</code></pre></div><p>We can see that, as expected, only <code>traefik</code> is available.</p>
<p>Now, let&rsquo;s take a look at an Ingress definition.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/ingress.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">networking.k8s.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ingressClassName</span>: <span style="color:#ae81ff">traefik</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">rules</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">silly-demo.35.185.11.184.nip.io</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">http</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">paths</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">service</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">port</span>:
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">number</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">pathType</span>: <span style="color:#ae81ff">ImplementationSpecific</span></span></span></code></pre></div><p>This time, the <code>kind</code> is set to <code>Ingress</code>. It has <code>ingressClassName</code> set to <code>traefik</code> since that&rsquo;s the one we&rsquo;re using today.</p>
<p>The important part is the <code>rules</code> section which contains a list of&hellip; well&hellip; rules. In this case, there is only one that say that requests coming from the <code>silly-demo</code> what so not subdomain of <code>nip.io</code> should be redirected to the <code>silly-demo</code> <code>service</code> on the <code>port</code> <code>8080</code>.</p>
<p>Since for this example, we need a domain, and I did not have any at hand, we&rsquo;re using nip.io service which provides a &ldquo;simulation&rdquo; of &ldquo;real&rdquo; domains. It forwards any request coming to it to the IP specified as subdomain. Nip.io has nothing to do with Kubernetes or APIs we&rsquo;re exploring. It&rsquo;s just a convenient way to test resources that requires a domain without having a domain to spare.</p>
<p>Now, before we see it in action, we&rsquo;ll have to change the <code>host</code> to have the auto-generated IP of the external load balancer. That&rsquo;s the one we stored in the environment variable EXTERNAL_IP. We&rsquo;ll execute <code>yq</code> command to modify that YAML.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>yq --inplace <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#e6db74">&#34;.spec.rules[0].host = \&#34;silly-demo.</span>$EXTERNAL_IP<span style="color:#e6db74">.nip.io\&#34;&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    service/ingress.yaml</span></span></code></pre></div><p>Now we can apply the Ingress resource.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply --filename service/ingress.yaml</span></span></code></pre></div><p>The Traefik controller should have detected that Ingress resource and used the information contained in it to update the configuration of the proxy running inside the cluster. That proxy is, today, Traefik we installed earlier.</p>
<p>Typically, every application that should be accessible from outside the cluster would have it&rsquo;s own Ingress resource and each of those resources would configure the proxy with additional rules how to redirect traffic based on hosts or some other criteria.</p>
<p>Let&rsquo;s see whether it works by sending a request to the make-believe domain <code>nip.io</code> and&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl <span style="color:#e6db74">&#34;http://silly-demo.</span>$EXTERNAL_IP<span style="color:#e6db74">.nip.io&#34;</span></span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>This is a silly demo</code></pre></div><p>There we go. We got the response.</p>
<p>Here&rsquo;s what we did and what happened.</p>
<img src="diag-05.png" style="width:70%; float:right; padding: 10px">
<p>We have a cluster with ClusterIP Service that is inaccessible from anywhere but other Pods inside the same cluster. That Service is associated to a few replicas, a few Pods of an application.</p>
<p>We installed Traefik, one of many Ingress controllers which provides implementation of the Ingress specification and acts as a proxy.</p>
<p>Among other things, Ingress controller created a LoadBalancer service which, in turn, exposed a few random ports on the nodes, one for HTTP and the other for HTTPS traffic, and created and configured external load balancer.</p>
<p>Further on, we applied an Ingress resource that reconfigured the proxy to forward requests coming from a specific domain to the service.</p>
<p>From there on, whenever we send a request to that domain, it would reach the external load balancer which forwards it to the Ingress Service which forwards it to the proxy, to the ingress controller. The proxy evaluates the request and, in our case, if it matches the domain associated with the application, forwards it to the ClusterIP service which, in turn, forwards it further to one of the Pods associated with it.</p>
<p>From here on, we can keep adding Services associated to Pods and Ingress resources that will configure Ingress proxy so that requests coming to other domains are forwarded to other applications.</p>
<p>Here comes an important note though. If you&rsquo;re using Ingress today, you can continue using it for a while longer. But, if you&rsquo;re just starting, you might skip Ingress since its days are numbered. It&rsquo;ll be replaced with Gateway API.</p>
<h2 id="kubernetes-gateway-api">Kubernetes Gateway API</h2>
<p>Kubernetes Ingress specification proved to be too limiting. As a result, Ingress controllers provided through other projects ended up adding their own capabilities through labels and annotations or not even using Ingress spec at all. If I would have to choose a Kubernetes API that proved to be more problematic than any other, Ingress would be, without doubt, my choice.</p>
<p>Kubernetes community realized not only that Ingress specification is not optimal but also that we hit the wall that prevents us from improving it to meet Kubernetes user&rsquo;s needs. As a result, a completely different specification was born. We got Gateway API. Just as Ingress, it is only a specification that other projects should implement. But, unlike Ingress, that specification was designed to accomodate most of the needs we have as well as to be extensible making it future-proof.</p>
<p>I expect Gateway API to become the default choice in the future and those starting now are advized to skip Ingress altogether and jump straight into Gateway API while those already using Ingress should be transitioning to it.</p>
<p>Now, Gateway API is a big subject by itself which we won&rsquo;t have time to explore in depth in the <a href="https://youtu.be/YAtXTI3NKtI" rel="external" target="_blank">Gateway API - Ingress And Service Mesh Spec Replacement?</a> video. Besides that, I don&rsquo;t like repeating what I already explored in previous videos so if you&rsquo;re not familiar with it, you might want to watch this one. The link is in the description. Just don&rsquo;t do it now. Finish this video first since I am about to give a very quick introduction.</p>
<p>Today, I&rsquo;m using Google Kubernetes Engine which has the option to simply enable Gateway API without the need to install it. Depending on Kubernetes provider or distribution you&rsquo;re using, you might not be so lucky and might need to install it separately.</p>
<p>Anyways&hellip; If I list all <code>gatewayclasses</code>,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get gatewayclasses</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME                               CONTROLLER                  ACCEPTED   AGE
gke-l7-global-external-managed     networking.gke.io/gateway   True       47m
gke-l7-gxlb                        networking.gke.io/gateway   True       47m
gke-l7-regional-external-managed   networking.gke.io/gateway   True       47m
gke-l7-rilb                        networking.gke.io/gateway   True       47m</code></pre></div><p>&hellip;we can see that four Gateway API classes are available. The major difference between those is in the type of the external load balancer will be created.</p>
<p>Unlike Ingress which is a single resource, Gateway API is split into multiple types.</p>
<p>Firth, there is the Gateway resource like this one.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/gateway.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Gateway</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">gateway.networking.k8s.io/v1beta1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">gatewayClassName</span>: <span style="color:#ae81ff">gke-l7-global-external-managed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">listeners</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">HTTP</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span></span></span></code></pre></div><p>The <code>Gateway</code> resource defines which Gateway Class (<code>gatewayClassName</code>) we should use and what the protocol and port will be used or, to be more precise, configured in the external load balancer.</p>
<p>Let&rsquo;s apply it,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply --filename service/gateway.yaml</span></span></code></pre></div><p>&hellip;and output <code>gateways</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get gateways</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME   CLASS                            ADDRESS   PROGRAMMED   AGE
http   gke-l7-global-external-managed             Unknown      5s</code></pre></div><p>Just as with Ingress, it might take a while until the external load balancer is created and configured so the <code>ADDRESS</code> is empty and it has not yet been <code>PROGRAMMED</code>.</p>
<p>If we wait for a few moments&hellip; and output the <code>gateways</code> again,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get gateways</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME   CLASS                            ADDRESS        PROGRAMMED   AGE
http   gke-l7-global-external-managed   34.120.55.14   True         81s</code></pre></div><p>We can see that we got the IP, the <code>ADDRESS</code>, and that the load balancer has been configured or, in Gateway API terms, <code>PROGRAMMED</code>.</p>
<p>Let&rsquo;s store that IP in a variable. We&rsquo;ll need it soon.</p>
<blockquote>
<p>Replace <code>[...]</code> with the <code>ADDRESS</code></p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export EXTERNAL_IP<span style="color:#f92672">=[</span>...<span style="color:#f92672">]</span></span></span></code></pre></div><p>What we did so far was, in a way, equivalent to installing Ingress controller, but with more flexibility.</p>
<p>Next, let&rsquo;s take a look at a <code>route</code> definition.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat service/route.yaml</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">HTTPRoute</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">gateway.networking.k8s.io/v1beta1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">parentRefs</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Gateway</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">hostnames</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">silly-demo.34.120.55.14.nip.io</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">rules</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">backendRefs</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">silly-demo</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span></span></span></code></pre></div><p>This is similar to defining an Ingress resource. We&rsquo;re instructing it which <code>Gateway</code> to use, telling it what the host name is (<code>silly-demo.*.nip.io</code>), and what the <code>rules</code> are. In this case, there is only a single rule instructing it to forward requests to the service <code>silly-demo</code> on the port <code>8080</code>.</p>
<p>Next, I&rsquo;ll change the host to use nip.io with the IP of the external load balancer,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>yq --inplace <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#e6db74">&#34;.spec.hostnames[0] = \&#34;silly-demo.</span>$EXTERNAL_IP<span style="color:#e6db74">.nip.io\&#34;&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    service/route.yaml</span></span></code></pre></div><p>&hellip;and apply the manifest.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team apply --filename service/route.yaml</span></span></code></pre></div><p>If we output <code>httproutes</code>,&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --namespace a-team get httproutes</span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>NAME         HOSTNAMES                            AGE
silly-demo   [&#34;silly-demo.34.120.55.14.nip.io&#34;]   3s</code></pre></div><p>&hellip;we can see that it was created and that it uses the nip.io as the host (<code>HOSTNAMES</code>).</p>
<p>That&rsquo;s it. From now on, if we send a request to that host,&hellip;</p>
<p>TODO: Ignore screen coming up&hellip;</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl <span style="color:#e6db74">&#34;http://silly-demo.</span>$EXTERNAL_IP<span style="color:#e6db74">.nip.io&#34;</span></span></span></code></pre></div><p>The output is as follows.</p>
<div class="highlight wrap-code"><pre tabindex="0"><code>This is a silly demo</code></pre></div><p>&hellip;we get the familiar response.</p>
<blockquote>
<p>The output might show an error (e.g., <code>fault filter abort</code>). If that&rsquo;s the case, the route was not yet configured. Wait for a few moments and re-run the <code>curl</code> command.</p>
</blockquote>
<p>There&rsquo;s much more to Gateway API than what we just saw. It servers the same basic purpose as Ingress, while providing quite a few additional capabilities. It is a specification designed to accomodate the needs of different implementations while, at the same time, it provides much more flexibility to end users.</p>
<p>Use it instead of Ingress.</p>
<h2 id="goodbye-for-now">Goodbye (For Now)</h2>
<p>That&rsquo;s it. Now you have a basic understanding of Kubernetes Service and Networking APIs. You should be able to decide which one to use depending on your use-cases.</p>
<p>As a summary, we always need Services which, most of the time, should be ClusterIP types. There are very few cases when they should be NodePort or LoadBalancer types. If we need to enable external access to our applications, we should be using Ingress or Gateway API. Ingress is the widely used, yet soon to be deprecated API that will be replaced by Gateway API. Most third-party applications rely on Ingress while you might want to choose Gateway API for your own applications since you have the freedom to choose. That means that we might have to use both for a while longer, at least until third-party apps switch to it.</p>
<h2 id="destroy">Destroy</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gcloud compute firewall-rules delete silly-demo-node-port <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --project $PROJECT_ID --quiet
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcloud container clusters delete dot --project $PROJECT_ID <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --zone us-east1-b --quiet
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcloud projects delete $PROJECT_ID --quiet
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rm $KUBECONFIG
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exit</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
<a href="/"><img src="/dot-narrow-yellow-bg.png"/></a>
        </div>
      </div>
      <div id="R-homelinks" class="default-animation">
        <hr class="padding">
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div id="R-topics">
          <ul class="enlarge morespace collapsible-menu">
          <li data-nav-id="/kubernetes/index.html" class="parent "><a class="padding" href="/kubernetes/index.html">Kubernetes</a><ul id="R-subsections-8254d660fdb6facefc4c74985669b8f4" class="morespace collapsible-menu">
          <li data-nav-id="/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler/index.html" class=""><a class="padding" href="/kubernetes/scaling-explained-through-kubernetes-hpa-vpa-keda--cluster-autoscaler/index.html">Scaling Explained Through Kubernetes HPA, VPA, KEDA &amp; Cluster Autoscaler</a></li>
          <li data-nav-id="/kubernetes/services-ingress-cluster-api/index.html" class="active"><a class="padding" href="/kubernetes/services-ingress-cluster-api/index.html">Mastering Kubernetes: Dive into Service and Network APIs</a></li>
          <li data-nav-id="/kubernetes/clusterpedia/index.html" class=""><a class="padding" href="/kubernetes/clusterpedia/index.html">Single Pane of Glass for Kubernetes Clusters with Clusterpedia</a></li>
          <li data-nav-id="/kubernetes/workloads/index.html" class=""><a class="padding" href="/kubernetes/workloads/index.html">Mastering Kubernetes: Dive into Workloads APIs</a></li>
          <li data-nav-id="/kubernetes/chainsaw/index.html" class=""><a class="padding" href="/kubernetes/chainsaw/index.html">Mastering Kubernetes Testing Kyverno Chainsaw!</a></li></ul></li>
          <li data-nav-id="/internal-developer-platforms/index.html" class=""><a class="padding" href="/internal-developer-platforms/index.html">Internal Developer Platforms</a><ul id="R-subsections-cf60b5d17e7b06cb9919bd0e19164658" class="morespace collapsible-menu">
          <li data-nav-id="/internal-developer-platforms/mastering-developer-portals-discover--integrate-api-schemas-with-port/index.html" class=""><a class="padding" href="/internal-developer-platforms/mastering-developer-portals-discover--integrate-api-schemas-with-port/index.html">Mastering Developer Portals: Discover &amp; Integrate API Schemas with Port</a></li>
          <li data-nav-id="/internal-developer-platforms/platform-engineering-menu/index.html" class=""><a class="padding" href="/internal-developer-platforms/platform-engineering-menu/index.html">How Platform Engineering Compares to Running a Restaurant</a></li></ul></li>
          <li data-nav-id="/app-management/index.html" class=""><a class="padding" href="/app-management/index.html">Application Management</a><ul id="R-subsections-acc2f76ee49e6b63b99cd477d8cb8b6d" class="morespace collapsible-menu">
          <li data-nav-id="/app-management/kcl/index.html" class=""><a class="padding" href="/app-management/kcl/index.html">Exploring KCL: Configuration and Data Structure Language; CUE and Pkl Replacement?</a></li>
          <li data-nav-id="/app-management/pkl/index.html" class=""><a class="padding" href="/app-management/pkl/index.html">Is Pkl the Ultimate Data Format? Unveiling the Challenger to YAML, JSON, and CUE</a></li></ul></li>
          <li data-nav-id="/development-environments/index.html" class=""><a class="padding" href="/development-environments/index.html">Development Environments</a><ul id="R-subsections-b40bb3dd3715504862627d465ed722c6" class="morespace collapsible-menu">
          <li data-nav-id="/development-environments/nix/index.html" class=""><a class="padding" href="/development-environments/nix/index.html">Nix for Everyone: Unleash Devbox for Simplified Development</a></li></ul></li>
          <li data-nav-id="/security/index.html" class=""><a class="padding" href="/security/index.html">Security</a><ul id="R-subsections-c5de21032b29c68377970042d4aea500" class="morespace collapsible-menu">
          <li data-nav-id="/security/eso-crossplane/index.html" class=""><a class="padding" href="/security/eso-crossplane/index.html">How to Propagate Secrets Everywhere with External Secrets Operator (ESO) and Crossplane</a></li></ul></li>
          <li data-nav-id="/ci-cd/index.html" class=""><a class="padding" href="/ci-cd/index.html">CI/CD</a><ul id="R-subsections-40535477fc00cad44ebee71dd34d26b1" class="morespace collapsible-menu">
          <li data-nav-id="/ci-cd/gitops-broke-ci-cd-here-is-how-to-fix-it-with-argo-events/index.html" class=""><a class="padding" href="/ci-cd/gitops-broke-ci-cd-here-is-how-to-fix-it-with-argo-events/index.html">GitOps Broke CI/CD! Here is How to Fix It With Argo Events</a></li>
          <li data-nav-id="/ci-cd/if-dockerfile-and-makefile-had-a-baby-earthly-and-earthfile/index.html" class=""><a class="padding" href="/ci-cd/if-dockerfile-and-makefile-had-a-baby-earthly-and-earthfile/index.html">If Dockerfile and Makefile Had a Baby... Earthly and Earthfile</a></li>
          <li data-nav-id="/ci-cd/from-makefile-to-justfile-or-taskfile-recipe-runner-replacement/index.html" class=""><a class="padding" href="/ci-cd/from-makefile-to-justfile-or-taskfile-recipe-runner-replacement/index.html">Mastering Kubernetes Testing Kyverno Chainsaw!</a></li>
          <li data-nav-id="/ci-cd/say-goodbye-to-makefile-use-taskfile-to-manage-tasks-in-ci-cd-pipelines-and-locally/index.html" class=""><a class="padding" href="/ci-cd/say-goodbye-to-makefile-use-taskfile-to-manage-tasks-in-ci-cd-pipelines-and-locally/index.html">Say Goodbye to Makefile - Use Taskfile to Manage Tasks in CI/CD Pipelines and Locally</a></li></ul></li>
          <li data-nav-id="/infrastructure-as-code/index.html" class=""><a class="padding" href="/infrastructure-as-code/index.html">Infrastructure-as-Code (IaC)</a><ul id="R-subsections-63fd9b6112be1a402112d4e0bc5eabbc" class="morespace collapsible-menu">
          <li data-nav-id="/infrastructure-as-code/ansible-vs-terraform-vs-crossplane/index.html" class=""><a class="padding" href="/infrastructure-as-code/ansible-vs-terraform-vs-crossplane/index.html">Terraform vs. Crossplane vs. Ansible - Rivals or Allies?</a></li></ul></li>
          <li data-nav-id="/observability/index.html" class=""><a class="padding" href="/observability/index.html">Observability</a><ul id="R-subsections-c8a379ef3c08db46130a08907982a264" class="morespace collapsible-menu">
          <li data-nav-id="/observability/inspektor-gadget-kubernetes-debugging-ebpf/index.html" class=""><a class="padding" href="/observability/inspektor-gadget-kubernetes-debugging-ebpf/index.html">Mastering Kubernetes Debugging: Leveraging eBPF with Inspektor Gadget</a></li></ul></li>
          <li data-nav-id="/wasm/index.html" class=""><a class="padding" href="/wasm/index.html">WebAssembly (WASM)</a><ul id="R-subsections-b0ea8ce9b33b696880b6f35f6467d614" class="morespace collapsible-menu">
          <li data-nav-id="/wasm/unleashing-webassembly-in-kubernetes-with-kwasm/index.html" class=""><a class="padding" href="/wasm/unleashing-webassembly-in-kubernetes-with-kwasm/index.html">Unleashing WebAssembly in Kubernetes with Kwasm</a></li></ul></li>
          <li data-nav-id="/cloud/index.html" class=""><a class="padding" href="/cloud/index.html">Cloud</a><ul id="R-subsections-04db32118cfbb6755505814035576930" class="morespace collapsible-menu">
          <li data-nav-id="/cloud/single-pane-of-glass-for-everything-aws-azure-gcp-kubernetes-with-steampipe/index.html" class=""><a class="padding" href="/cloud/single-pane-of-glass-for-everything-aws-azure-gcp-kubernetes-with-steampipe/index.html">Single Pane of Glass for Everything (AWS, Azure, GCP, Kubernetes, ...) with Steampipe</a></li></ul></li>
          <li data-nav-id="/terminal/index.html" class=""><a class="padding" href="/terminal/index.html">Terminals</a><ul id="R-subsections-487e4f01eb2fcd73ad92a1f1221e4869" class="morespace collapsible-menu">
          <li data-nav-id="/terminal/from-boring-to-productive-customize-your-shell-prompt-with-starship/index.html" class=""><a class="padding" href="/terminal/from-boring-to-productive-customize-your-shell-prompt-with-starship/index.html">From Boring to Productive: Customize Your Shell Prompt with Starship</a></li></ul></li>
          <li data-nav-id="/about/index.html" class=""><a class="padding" href="/about/index.html">About The DeveOps Toolkit</a></li>
          <li data-nav-id="/sponsor/index.html" class=""><a class="padding" href="/sponsor/index.html">Sponsor DevOps Toolkit</a></li>
          </ul>
        </div>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showFooter"></div>
        <div id="R-menu-footer">
          <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showFooter">
          <div id="R-prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks">
            <ul>
              <li id="R-select-language-container" class="footerLangSwitch">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-language"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-language">Language</label>
                    <select id="R-select-language" onchange="location = this.querySelector( this.value ).dataset.url;">
                      <option id="R-select-language-en" value="#R-select-language-en" data-url="/kubernetes/services-ingress-cluster-api/index.html" lang="en-us" selected></option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
              <li id="R-select-variant-container" class="footerVariantSwitch">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-paint-brush"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-variant">Theme</label>
                    <select id="R-select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                      <option id="R-select-variant-dot" value="dot" selected>Dot</option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
                <script>window.variants && variants.markSelectedVariant();</script>
              </li>
              <li class="footerVisitedLinks">
                <div class="padding menu-control">
                  <i class="fa-fw fas fa-history"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <button onclick="clearHistory();">Clear History</button>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
            </ul>
          </div>
          <div id="R-footer" class="footerFooter showFooter">
	    <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
          </div>
        </div>
      </div>
    </aside>
    <script src="/js/clipboard.min.js?1721771712" defer></script>
    <script src="/js/perfect-scrollbar.min.js?1721771712" defer></script>
    <script src="/js/theme.js?1721771712" defer></script>
  </body>
</html>
